<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>无标题文档</title>
    <style type="text/css">
        img{
            -webkit-filter: brightness(0.5);
            filter: brightness(0.5);
        }
        body,td,th {
            color: #FFFFFF;
            font-style: normal;
            font-weight: normal;
            font-size: 28px;
            font-family: Consolas;
        }
        #centtt{
            text-align: center
        }
        .div1 { font-size: 30px; color: yellow}
        .div1:hover { font-size: 35px; color: white }
        body {
            background-color: #000000;
            background-repeat: repeat;
        }



        a:link {
            text-decoration: none;
            color: #FFFFFF;
        }

        a:visited {
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
            color: #000000;
        }

        a:active {
            text-decoration: none;
        }

    .dropdown {            position: relative;
            display: inline-block;
}
.dropdown-content {            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 60px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
}
    </style>

</head>

<body>
<p>
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-2" count="120" src="../js/1.js"></script>
</p>
<div class="topnav"><a href="首页2.html">HomePage</a> <a href="建站思路.html">建站思路</a> <a href="算法导图.html">算法导图</a>
  <div class="dropdown" style="float: right">
    <button class="topnav">
    <a>登录</a>
    </button>
    <div class="dropdown-content"> <a>登录</a> <a>注册</a> </div>
  </div>
</div>
<p>
<script type="text/javascript" color="255,255,255" opacity='1' zIndex="-2" count="120" src="../js/1.js"></script></p>
<table width="1580" border="0" align="center" cellpadding="0">
    <tbody>
    <tr>
        <td height="305" colspan="3" ><h1 id="centtt">动态规划</h1></td>
    </tr>
    <tr>
        <td width="111" height="605" rowspan="7">&nbsp;</td>
        <td height="76">What is Dynamic Programming ?</td>
        <td width="83" rowspan="7">&nbsp;</td>
    </tr>
    <tr>
        <td height="290">动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初,美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 </td>
    </tr>
    <tr>
        <td width="1378" height="169"><p>&nbsp;</p></td>
    </tr>
    <tr>
        <td height="83">动态规划入门问题__背包九讲</td>
    </tr>
    <tr>
        <td height="475"><p>&nbsp;</p>
            <p>1.1 01背包
            <p>N件物品放入体积V的背包中, 第<span tabindex="0" id="MathJax-Element-4-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>      i</annotation></semantics></math>"><span id="MathJax-Span-20"><span id="MathJax-Span-21"><span id="MathJax-Span-22"><span id="MathJax-Span-23"><span id="MathJax-Span-24">i</span></span></span></span></span></span>件物品的费用是<span tabindex="0" id="MathJax-Element-5-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>w</mi><mo stretchy='false'>[</mo><mi>i</mi><mo stretchy='false'>]</mo></mrow><annotation encoding='application/x-tex'>      w[i]</annotation></semantics></math>"><span id="MathJax-Span-25"><span id="MathJax-Span-26"><span id="MathJax-Span-27"><span id="MathJax-Span-28"><span id="MathJax-Span-29">w</span><span id="MathJax-Span-30">[</span><span id="MathJax-Span-31">i</span><span id="MathJax-Span-32">]</span></span></span></span></span></span>，价值是<span aria-hidden="true">v[i]</span>. 求将哪些物品装入背包可使价值总和最大?
	    <pre><code>


                #include <iostream>
                #include <cstring>
                #include <algorithm>
                using namespace std;
                #define maxV 1000

                int main(void) {
                int times, n, v, ci, wi;
                int f[maxV];
                freopen("1.txt", "r", stdin);
                cin >> times;
                while (times--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v;
                for (int i = 0; i < n; i++) {
                    cin >> ci >> wi;
                    for (int j = v; j >= 0; j--) {
                        if (j >= ci)
                        f[j] = max(f[j - ci] + wi, f[j]);
                    }
                }
                for (int i = 0; i <= v; i++) cout << f[i] << " ";
                        cout << endl;
                        cout << f[v] << endl;
                    }
                }

        </code></pre>
            </p>
            <p>&nbsp;</p>
            <p>1.2 完全背包

            <p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。<br>
	    <pre><code>



            #include <iostream>
            #include <cstring>
            #include <algorithm>
            using namespace std;
            #define maxV 1000

            int main(void) {
            int cases, n, v, ci, wi;
            int f[maxV];
            freopen("2.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v;
                for (int i = 0; i < n; i++) {
                    cin >> ci >> wi;
                    for (int j = 0; j <= v; j++) {
                        if (j >= ci)
                            f[j] = max(f[j], f[j - ci] + wi);
                    }
                }
                cout << f[v] << endl;
                }
            }


        </code></pre>
            <p>1.3 二费背包
            <p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为w[i]和g[i]。两种代价可付出的最大值（两种背包容量）分别为V和T。物品的价值为v[i].
        <pre><code>



            #include <iostream>
            #include <cstring>
            #include <algorithm>
            using namespace std;
            #define maxV 1000
            #define maxU 1000

            int main(void) {
            int cases, n, v, u, ai, bi, wi;
            int f[maxV][maxU];
            freopen("5.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v >> u;
                for (int i = 0; i < n; i++) {
                    cin >> ai >> bi >> wi;
                    for (int j = v; j >= 0; j--) {
                        for (int k = u; k >= 0; k--) {
                            if (ai <= j && bi <= k)
                                f[j][k] = max(f[j][k], f[j - ai][k - bi] + wi);
                        }
                    }
                }
                cout << f[v][u] << endl;
                }
            }

        </code></pre>
            </p>
            <p>1.4 多重背包
            <p>有N种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
            <p><br>
        <pre><code>


            #include <iostream>
            #include <algorithm>
            using namespace std;
            #define maxV 1000

            int f[maxV], v;

            void ZeroOnePack(int ci, int wi) {
                for (int j = v; j >= 0; j--)
                    if (j >= ci)
                        f[j] = max(f[j], f[j - ci] + wi);
            }

            void CompletePack(int ci, int wi) {
                for (int j = 0; j <= v; j++)
                    if (j >= ci)
                        f[j] = max(f[j], f[j - ci] + wi);
            }



            void MultiplePack(int ni, int ci, int wi) {
                if (ni * ci >= v) {
                    CompletePack(ci, wi);
                    return;
                }
                int k = 1, amount = ni;
                while (k < ni) {
                    ZeroOnePack(ci * k, wi * k);
                    amount -= k;
                    k *= 2;
                }
                ZeroOnePack(ci * amount, wi * amount);
            }

            int main(void) {
            int cases, n, ni, ci, wi;
            freopen("3.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v;
                for (int i = 0; i < n; i++) {
                    cin >> ni >> ci >> wi;
                    MultiplePack(ni, ci, wi);
                }
                //for (int i = 0; i <= v; i++) cout << f[i] << " "; cout << endl;
                cout << f[v] << endl;
                }
            }

        </code></pre>
            </p>
            <p>1.5 分组背包
            <p>有N件物品和一个容量为V的背包。第i件物品的费用是w[i]，价值是v[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。<br>
            <p>
		<pre><code>

            #include <iostream>
            #include <cstring>
            #include <vector>
            #include <algorithm>


            using namespace std;
            #define maxV 1000
            #define maxG 100
            #define maxN 100

            int main(void) {
            int cases, n, v, g, gi;
            int f[maxV];
            int ci[maxN], wi[maxN];
            freopen("6.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v >> g;
                vector<vector<int> > gMap(g);
                for (int i = 0; i < n; i++) {
                    cin >> ci[i] >> wi[i] >> gi;
                    gMap[gi].push_back(i);
                }
                for (int i = 0; i < g; i++) {
                    for (int j = v; j >= 0; j--) {
                        for (int k = 0; k < gMap[i].size(); k++) {
                            if (j >= ci[gMap[i][k]])
                                f[j] = max(f[j], f[j - ci[gMap[i][k]]] + wi[gMap[i][k]]);
                        }
                    }
                }
                cout << f[v] << endl;
            }
            }

        </code></pre>
            </p>
            <p>1.6 有依赖背包
            <p>这种背包问题的物品间存在某种&ldquo;依赖&rdquo;的关系。也就是说，<span tabindex="0" id="MathJax-Element-242-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>      i</annotation></semantics></math>"><span id="MathJax-Span-2739"><span id="MathJax-Span-2740"><span id="MathJax-Span-2741"><span id="MathJax-Span-2742"><span id="MathJax-Span-2743">i</span></span></span></span></span><span role="presentation">i      i</span></span><span aria-hidden="true"> i</span>依赖于<span tabindex="0" id="MathJax-Element-243-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>      j</annotation></semantics></math>"><span id="MathJax-Span-2744"><span id="MathJax-Span-2745"><span id="MathJax-Span-2746"><span id="MathJax-Span-2747"><span id="MathJax-Span-2748">j</span></span></span></span></span><span role="presentation">j      j</span></span><span aria-hidden="true"> j</span>，表示若选物品<span tabindex="0" id="MathJax-Element-244-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>      i</annotation></semantics></math>"><span id="MathJax-Span-2749"><span id="MathJax-Span-2750"><span id="MathJax-Span-2751"><span id="MathJax-Span-2752"><span id="MathJax-Span-2753">i</span></span></span></span></span><span role="presentation">i      i</span></span><span aria-hidden="true"> i</span>，则必须选物品<span tabindex="0" id="MathJax-Element-245-Frame" role="presentation" data-mathml="<math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>      j</annotation></semantics></math>"><span id="MathJax-Span-2754"><span id="MathJax-Span-2755"><span id="MathJax-Span-2756"><span id="MathJax-Span-2757"><span id="MathJax-Span-2758">j</span></span></span></span></span><span role="presentation">j      j</span></span><span aria-hidden="true"> j</span>。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。
            <p>
            <p>
		<pre><code>


            #include <iostream>
            #include <vector>
            #include <cstring>
            #include <algorithm>

            using namespace std;
            #define maxV 1000
            #define maxG 100


            int main(void) {
            int cases, n, v, ci[maxV], wi[maxV], di, f[maxV];
            freopen("7.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
            memset(f, 0, sizeof(f));
            cin >> n >> v;
            // group[i]空表示i号物品有依赖，因此存放到其他组里
            // 只有一个元素表示i号物品既无依赖也不被依赖
            // 有多个元素表示i号物品被依赖，这里自己的编号i也被存放进group[i]
            vector<vector<int> > groups(n);
            // 读入数据并储存起来
            for (int i = 0; i < n; i++) {
            cin >> ci[i] >> wi[i] >> di;
            if (di == -1) groups[i].push_back(i);
            else groups[di].push_back(i);
            }
            // 对每个有多个元素的组进行01背包
            for (int i = 0; i < n; i++) {
                if (groups[i].size() > 1) {
                    vector<int> giOri; //group[i]的拷贝，排除i本身
                    int newV = v - ci[i];
                    // 复制group[i]中的元素，排除i
                    for (int j = 0; j < groups[i].size(); j++) {
                        if (groups[i][j] != i)
                            giOri.push_back(groups[i][j]);
                    }// 把等效物品组存入group[i]中
                    groups[i].clear();
                    groups[i].resize(newV + 1, 0);
                    for (int j = 0; j < giOri.size(); j++) {
                        for (int k = newV; k >= 0; k--) {
                            if (ci[giOri[j]] <= k) {
                                groups[i][k] = max(groups[i][k], groups[i][k - ci[giOri[j]]] + wi[giOri[j]]);
                            }
                        }
                    }
                }}

                // 进行分组背包
                for (int i = 0; i < n; i++) {
                    if (groups[i].size() == 0) continue;
                    else if (groups[i].size() == 1) { // i物品无依赖且不被依赖
                        for (int j = v; j >=0; j--) {
                            if (j >= ci[i])
                                f[j] = max(f[j], f[j - ci[i]] + wi[i]);
                    }
                } else { // i物品被依赖, i组第k个物品的cost为k + ci[i], weight为group[i][k] + wi[i]
                    for (int j = v; j >= 0; j--) {
                        for (int k = 0; k < groups[i].size(); k++) {
                            if (j >= k + ci[i])
                                f[j] = max(f[j], f[j - k - ci[i]] + groups[i][k] + wi[i]);
                            }
                        }
                    }
                }
                cout << f[v] << endl;
                }
                }
        </code></pre>
            </p>
            <p>1.7 混合背包
            <p>如果将前面三个背包混合起来，也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包），应该怎么求解呢？
            <p>
	  <pre><code>

          #include <iostream>
          #include <cstring>
          using namespace std;
          #define maxV 1000
          int f[maxV], v;

          void ZeroOnePack(int ci, int wi) {
            for (int j = v; j >= 0; j--)
                if (j >= ci)
                    f[j] = max(f[j], f[j - ci] + wi);
          }

          void CompletePack(int ci, int wi) {
            for (int j = 0; j <= v; j++)
                if (j >= ci)
                    f[j] = max(f[j], f[j - ci] + wi);
          }


          void MultiplePack(int ni, int ci, int wi) {
            if (ni * ci >= v) {
                CompletePack(ci, wi);
                return;
            }
            int k = 1, amount = ni;
            while (k < ni) {
            ZeroOnePack(ci * k, wi * k);
            amount -= k;
            k *= 2;
            }
            ZeroOnePack(ci * amount, wi * amount);
          }

          int main(void) {
                int cases, n, ni, ci, wi;
            freopen("4.txt", "r", stdin);
            cin >> cases;
            while (cases--) {
                memset(f, 0, sizeof(f));
                cin >> n >> v;
                for (int i = 0; i < n; i++) {
                cin >> ni >> ci >> wi;
                    if (ni == 1) ZeroOnePack(ci, wi);
                    else if (ni == -1) CompletePack(ci, wi);
                    else MultiplePack(ni, ci, wi);
                }
                for (int i = 0; i <= v; i++) cout << f[i] << " "; cout << endl;
                cout << f[v] << endl;
                }
          }
            </code>

</pre>
            </p>
            <p>
                1.8 泛化物品
            <p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。<br>
                更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0...V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。<br>
                这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0...V]，给它费用v，可得到价值h[V]。<br>
                一个费用为cc      cc价值为ww      ww的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为00      00的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当vv      vv被c整除时有h(v)=v/c*w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。一个物品组可以看作一个泛化物品h。对于一个0...V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。有依赖的背包问题中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。<br>
            <p>
            <p>
	  <pre><code>



          #include <iostream>
          #include <algorithm>
          using namespace std;
          #define maxN 100
          #define maxV 1000

          int n, v;
          int cnt = 0;
          int head[maxN];
          int wi[maxN], ci[maxN];
          int f[maxN][maxV];

          struct Edge {
            int v, next;
          } e[maxN - 1];

          void addEdge(int u, int v) {
            e[cnt].v = v;
            e[cnt].next = head[u];
            head[u] = cnt++;
          }

          void treeDP(int u) {
            for (int i = ci[u]; i <= v; i++) {
            f[u][i] = wi[u];
            }
            for (int i = head[u]; i != -1; i = e[i].next) {
                int curr = e[i].v;
                treeDP(curr);
                for (int j = v; j >= 0; j--) {
                    for (int k = j - ci[u]; k >= 0; k--) {
                        f[u][j] = max(f[u][j], f[u][j - k] + f[curr][k]);
                    }
                }
            }
          }

          int main(void) {
                int cases, root;
                freopen("8.txt", "r", stdin);
                cin >> cases;
            while (cases--) {
            cnt = 0;
            memset(head, -1, sizeof(head));
            memset(f, 0, sizeof(f));
            cin >> n >> v >> root;
            for (int i = 0; i < n; i++) {
                int di;
                cin >> ci[i] >> wi[i] >> di;
                addEdge(di, i);
            }
            treeDP(root);
            cout << f[root][v] << endl;
            }
          }

      </code></pre>

            </p>
            <p>
                背包问延伸
	  <pre><code>

          #include <iostream>
          #include <algorithm>
          using namespace std;
          #define maxV 1000
          #define maxN 100

          int main(void) {
          int cases, n, v, ci[maxN], wi;
          int f[maxV];
          bool g[maxN][maxV]; //g[i][v]=0 表示没放i时的f(i, v)较大，
          //g[i][v]=1 表示放进i时的f(i, v)较大
          freopen("9.txt", "r", stdin);

          cin >> cases;
          while (cases--) {
            memset(f, 0, sizeof(f));
            memset(g, 0, sizeof(g));
            cin >> n >> v;
            for (int i = 0; i < n; i++) {
            cin >> ci[i] >> wi;
            for (int j = v; j >= 0; j--) {
                if (j >= ci[i]) {
                    if (f[j - ci[i]] + wi > f[j]) {
                        f[j] = f[j - ci[i]] + wi;
                        g[i][j] = 1;
                     }
                }
            }
          }

          int i = n - 1, j = v;
            while (i >= 0) {
                if (g[i][j] == 1) {
                cout << "选了" << i << endl;
                j -= ci[i];
             } else {
                cout << "没选" << i << endl;
            }
            i--;
          }
          cout << endl;
          }
          }

      </code></pre>
            </p>
        </td>
    </tr>
    <tr>
        <td height="126"><a href="首页2.html" id="centtt" CLASS="div1">return Homepage;</a></td>
    </tr>
    <tr>
      <td height="127">&nbsp;</td>
    </tr>
    <tr>
        <!--http://player.bilibili.com/player.html?aid=16544031&cid=26985107&page=1-->
    </tr>
  </tbody>
</table>
</body>
</html>